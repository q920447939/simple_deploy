# 简易 Ansible 部署升级桌面工具（Simple Deploy）技术文档（v1）

最后更新：2026-01-13  
目标：在“不增加独立后端服务”的前提下，实现本地配置 + 下发到控制端执行 + 结果回收展示。

---

# 总体需求描述
桌面应用（Flutter Desktop）作为“UI + 执行器”，本地管理项目配置与历史执行记录；执行时将 playbook 与本次上传文件发送到控制端，由控制端使用 Ansible 直连被控端完成部署升级，并将日志/结果回传本地保存。

---

# 技术栈描述

## 1. 平台与运行形态
- Flutter Desktop：
  - Windows x64
  - Linux x64
- 单人使用：应用数据仅存本机。

## 2. 依赖建议（实现时可调整）
- SSH/SFTP：`dartssh2`（或同类库）
- 本地路径：`path_provider`
- 文件选择：`file_picker`
- 压缩：`archive`（zip）
- YAML 校验：Dart YAML 解析库（用于基础语法校验）
- 状态管理：Getx

## 3. 本地存储设计（仅文件）
### 3.1 数据目录
使用 `path_provider` 获取应用数据目录作为根目录，例如：
- Windows：`%APPDATA%/simple_deploy/`
- Linux：`~/.local/share/simple_deploy/`

### 3.2 项目目录结构（建议）
- `projects/<project_id>/project.json`
- `projects/<project_id>/servers.json`
- `projects/<project_id>/playbooks/`（yaml 文件）
- `projects/<project_id>/playbooks.json`（元信息）
- `projects/<project_id>/tasks.json`
- `projects/<project_id>/batches/<batch_id>.json`
- `projects/<project_id>/runs/<run_id>.json`
- `projects/<project_id>/run_artifacts/<run_id>/...`
- `projects/<project_id>/run_logs/<run_id>/task_<index>.log`
- `projects/<project_id>/locks/batch_<batch_id>.lock`

### 3.3 原子写入规范
所有 JSON 写入采用：
1) 写临时文件：`xxx.json.tmp`
2) `fsync`（如可用）
3) 原子 rename 覆盖：`xxx.json`

锁文件采用“原子创建”方式（create-new），失败则表示已被占用。

## 4. 核心执行协议（客户端 -> 控制端）

### 4.1 运行目录（控制端）
每次 Run 在控制端使用独立目录：
- `/tmp/simple_deploy/<project_id>/<run_id>/`

目录内建议结构：
- `playbooks/`
- `files/`（本次上传文件）
- `inventory.ini`
- `vars.json`
- `logs/`（控制端侧按任务写日志）
- `results/`
  - `run_result.json`
  - `biz_status.json`（可选）

### 4.2 执行包（bundle.zip）
客户端将以下内容打包成 zip 后下发：
- `playbooks/**`
- `files/**`
- `inventory.ini`
- `vars.json`
- （可选）`run.sh`

控制端负责解包到 run_dir。

### 4.3 inventory.ini 生成（最简）
不做分组，直接 `[all]`：
- `host_<id> ansible_host=<ip> ansible_user=root ansible_password=<pwd> ansible_port=<port> ansible_python_interpreter=/usr/local/bin/python3.12`

### 4.4 vars.json（推荐字段）
用于统一向 playbook 传参，并提供“本次上传文件映射”：
- `run_id`
- `run_dir`
- `files`：按 `task_id -> slot_name -> [relative_paths]` 组织

### 4.5 执行方式（逐任务串行）
对批次内任务按顺序执行（每任务对应一个 playbook）：
- `ansible-playbook -i inventory.ini playbooks/<task_playbook>.yml --extra-vars @vars.json`

输出处理：
- stdout/stderr 同时写入：
  - 控制端：`logs/task_<index>.log`
  - 客户端：实时展示（v1 可先“执行结束后拉取日志”，再迭代为流式）

失败策略：
- 任一任务退出码非 0：停止后续任务，写 `results/run_result.json`，Run 失败。

### 4.6 密码 SSH 依赖与自检
Ansible 默认使用系统 SSH，密码登录通常依赖 `sshpass`：
- v1 约束：控制端必须安装 `sshpass`
- 客户端执行前自检：
  - `ansible-playbook --version`
  - `sshpass -V`
  - （可选）对被控端做连通性探测（例如 `ansible -i inventory.ini all -m ping`）

## 5. 业务状态文件约定（可选）
### 5.1 文件位置
控制端 run_dir 下：
- `results/biz_status.json`

### 5.2 建议 schema
- `status`: `ok` | `failed` | `unknown`
- `message`: string
- `version`: string（可选）
- `timestamp`: string（可选）

### 5.3 Playbook 写入建议（概念）
通过 `--extra-vars @vars.json` 获取 `run_dir` 后：
- 在最后阶段 `delegate_to: localhost` 将 JSON 写到 `{{ run_dir }}/results/biz_status.json`。
- 若要把“业务失败”同步为任务失败：使用 `assert`/`fail` 触发非0退出码（让平台明确判失败）。

## 6. 并发模型（单人但允许多批次并发）
- RunManager：应用内维护正在运行的 Run 列表（按 project_id/batch_id 索引）。
- 同批次互斥：获取 `locks/batch_<batch_id>.lock` 成功才允许开始。
- 不同批次并发：可同时启动多个异步任务；避免 UI 卡顿（必要时 isolate）。

## 7. 错误处理与恢复
- 常见错误分类：
  - 客户端 -> 控制端 SSH 失败
  - 控制端缺少依赖（ansible/sshpass/tar/unzip）
  - 解包失败/权限不足
  - playbook 不存在/YAML 错误
  - ansible 退出码非0
- 恢复：
  - 提供“强制解锁/重置为暂停”
  - Run 记录只读保留，不回滚历史

---

# 开发约束
- 不部署后端服务；桌面应用承担调度与执行。
- 仅本地文件存储（JSON）。
- 明文密码；需在 UI 明示风险与适用边界（内网、单机、单人）。

---

# 视觉约束
- 批次详情：任务进度条 + 日志区域（任务切换、历史 Run 切换）为强制。

---

# 其他约束
- 控制端 run_dir 建议每次执行后保留（便于排障）；清理由后续版本再做。
- v1 实时日志可先做“执行后拉取”，但需要预留升级到“流式”的接口形态。

---

# 任务列表
## 任务1
- 定义数据结构与目录协议（与执行协议对齐）
## 任务2
- 实现 SSH/SFTP 上传与远程命令执行封装
## 任务3
- 实现 Run 串行执行、退出码判定与日志采集

